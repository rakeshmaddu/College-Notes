{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"index.html#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"index.html#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre> <p>This is sem notes</p>"},{"location":"DSA/code.html","title":"code","text":""},{"location":"DSA/code.html#week1","title":"Week1","text":"<ol> <li>Arrays &amp; Hashing: Contains Duplicate, Valid Anagram, Two Sum</li> <li>Pointers: Valid Palindrome, Two Sum II Input Array Is Sorted</li> <li>Sliding Window: Best Time to Buy And Sell Stock, Longest Substring Without Repeating Characters</li> <li>Stack: Valid Parentheses, Min Stack</li> <li>Binary Search: Binary Search, Search a 2D Matrix</li> <li>LinkedList: Reverse Linked List, Merge Two Sorted Lists</li> <li>Trees: Invert Binary Tree, Maximum Depth of Binary Tree</li> </ol>"},{"location":"DSA/code.html#contains-duplicate","title":"Contains Duplicate","text":"<pre><code>def containsDuplicate(self, nums: List[int]) -&gt; bool:\n        array_set = {}\n        for i in nums:\n            if(i in array_set):\n                return true\n            array_set.add(i)\n        return false\n</code></pre>"},{"location":"DSA/code.html#valid-anagram","title":"Valid Anagram","text":"<pre><code>def isAnagram(self, s: str, t: str) -&gt; bool:\n        if len(s) != len(t):\n            return False\n        s_dict = {}\n        t_dict = {}\n        for i in range(len(s)):\n            s_dict[s[i]] = s_dict.get(s[i],0)+1\n            t_dict[t[i]] = t_dict.get(t[i],0)+1\n        return s_dict==t_dict\n</code></pre>"},{"location":"DSA/code.html#two-sum","title":"Two Sum","text":"<pre><code>def twoSum(self, nums: List[int], target: int) -&gt; List[int]:\n        hashmap = {}\n        for i, num in enumerate(nums):\n            diff = target - num\n            if diff in hashmap:\n                return [hashmap[diff],i]\n            hashmap[num] = i\n        return [-1,-1]\n</code></pre>"},{"location":"DSA/code.html#valid-palindrome","title":"Valid Palindrome","text":"<pre><code>def isPalindrome(self, s: str) -&gt; bool:\n        left, right = 0, len(s) - 1\n        while(left &lt; right):\n            while(left&lt;right and not s[left].isalnum()):\n                left +=1\n            while(left&lt;right and not s[right].isalnum()):\n                right -=1\n            if(s[left].lower() != s[right].lower()):\n                return False\n            right -=1\n            left +=1\n        return True\n</code></pre>"},{"location":"DSA/code.html#two-sum-ii-input-array-is-sorted","title":"Two Sum II Input Array Is Sorted","text":"<pre><code>def twoSum(self, numbers: List[int], target: int) -&gt; List[int]:\n        left,right = 0, len(numbers) -1\n        while( left &lt; right):\n            if((numbers[left] + numbers[right])==target):\n                return [left+1,right+1]\n            elif((numbers[left] + numbers[right])&lt;target):\n                left+=1\n            else:\n                right-=1\n        return [-1,-1]\n</code></pre>"},{"location":"DSA/code.html#best-time-to-buy-and-sell-stock","title":"Best Time to Buy And Sell Stock","text":"<pre><code>def maxProfit(self, prices: List[int]) -&gt; int:\n        minprice = prices[0]\n        maxprofit =0\n        for price in prices:\n            minprice = min(price,minprice)\n            profit = price- minprice\n            maxprofit = max(profit,maxprofit)\n        return maxprofit\n</code></pre>"},{"location":"DSA/code.html#longest-substring-without-repeating-characters","title":"Longest Substring Without Repeating Characters","text":"<pre><code>def lengthOfLongestSubstring(self, s: str) -&gt; int:\n        hashset = set()\n        left = 0\n        maxlength = 0\n        for right in range(len(s)):\n            while(s[right] in hashset):\n                hashset.remove(s[left])\n                left+=1\n            hashset.add(s[right])\n            maxlength = max(right-left+1,maxlength)\n        return maxlength\n</code></pre>"},{"location":"DSA/code.html#valid-parentheses","title":"Valid Parentheses","text":"<pre><code>def isValid(self, s: str) -&gt; bool:\n        mapping = {'}':'{',\"]\":\"[\",\")\":\"(\"}\n        stack =[]\n        for char in s:\n            if char in mapping:\n                topelement = stack.pop() if stack else \"#\"\n                if mapping[char] != topelement:\n                    return False\n            else:\n                stack.append(char)\n        return not stack\n</code></pre>"},{"location":"DSA/code.html#min-stack","title":"Min Stack","text":"<pre><code>class MinStack:\n    def __init__(self):\n        self.stack = []\n        self.minstack = []\n\n\n    def push(self, val: int) -&gt; None:\n        self.stack.append(val)\n        if(not self.minstack or val&lt;=self.minstack[-1]):\n            self.minstack.append(val)\n\n\n    def pop(self) -&gt; None:\n        val = self.stack.pop()\n        if(val==self.minstack[-1]):\n            self.minstack.pop()\n\n\n    def top(self) -&gt; int:\n        return self.stack[-1]\n\n\n    def getMin(self) -&gt; int:\n        return self.minstack[-1]\n</code></pre>"},{"location":"DSA/code.html#binary-search","title":"Binary Search","text":"<pre><code>def search(self, nums: List[int], target: int) -&gt; int:\n        left,right = 0, len(nums) -1\n        while(left &lt;= right):\n            mid = (left+right) // 2\n            if(nums[mid] == target):\n                return mid\n            elif nums[mid] &gt; target:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return -1\n</code></pre>"},{"location":"DSA/code.html#search-a-2d-matrix","title":"Search a 2D Matrix","text":"<pre><code> def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:\n        top, bottom = 0, len(matrix) -1\n        while(top&lt;=bottom):\n            row = (top+bottom)//2\n            if(target&lt;matrix[row][0]):\n                bottom = row -1\n            elif(target&gt;matrix[row][-1]):\n                top = row +1\n            else:\n                break\n        if(not top&lt;=bottom):\n            return False\n        row = (top+bottom)//2\n        left, right = 0, len(matrix[row]) -1\n        while(left&lt;=right):\n            mid =  (left+right)//2\n            if(target == matrix[row][mid]):\n                return True\n            elif(target&lt;matrix[row][mid]):\n                right = mid-1\n            else:\n                left = mid+1\n        return False\n</code></pre>"},{"location":"DSA/code.html#reverse-linked-list","title":"Reverse Linked List","text":"<pre><code>def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        prev = None\n        curr = head\n        while(curr):\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n        return prev\n</code></pre>"},{"location":"DSA/code.html#merge-two-sorted-lists","title":"Merge Two Sorted Lists","text":"<pre><code>def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:\n        prevhead = ListNode(-1)\n        curr  = prevhead\n        while(list1 and list2):\n            if(list1.val&lt;=list2.val):\n                curr.next = list1\n                list1 = list1.next\n            else:\n                curr.next = list2\n                list2 = list2.next\n            curr = curr.next\n        curr.next = list1 if list1 else list2\n        return prevhead.next\n</code></pre>"},{"location":"DSA/code.html#invert-binary-tree","title":"Invert Binary Tree","text":"<p><pre><code>def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n         if not root:\n             return None\n         root.left,root.right = root.right,root.left\n         self.invertTree(root.left)\n         self.invertTree(root.right)\n         return root\n</code></pre> <pre><code>from collections import deque\n def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n        if not root:\n            return None\n        queue = deque([root])\n        while queue:\n            current = queue.popleft()\n            current.left,current.right = current.right, current.left\n            if current.left:\n                queue.append(current.left)\n            if current.right:\n                queue.append(current.right)\n        return root\n</code></pre></p>"},{"location":"DSA/code.html#maximum-depth-of-binary-tree","title":"Maximum Depth of Binary Tree","text":"<p><pre><code>def maxDepth(self, root: Optional[TreeNode]) -&gt; int:\n        if not root:\n            return 0\n        leftdepth = self.maxDepth(root.left)\n        rightdepth = self.maxDepth(root.right)\n        return max(leftdepth,rightdepth)+1\n</code></pre> <pre><code>from collections import deque\ndef maxDepth(self, root: Optional[TreeNode]) -&gt; int:\n        if not root:\n            return 0\n        queue = deque([root])\n        depth = 0\n        while queue:\n            depth += 1\n            size = len(queue)\n            for _ in range(size):\n                current = queue.popleft()\n                if current.left:\n                    queue.append(current.left)\n                if current.right:\n                    queue.append(current.right)\n        return depth\n</code></pre></p>"}]}